(define (p+ p1 p2) (clean (append p1 p2))) (define (p- p1 p2) (p+ p1 (negate-poly p2)))
(define (p* p1 p2) (clean (foldr append '() (cartesian-map term* p1 p2))))
(define (p= p1 p2) (null? (p- p1 p2))) (define (clean p) (simp-terms (simp-vars p)))
(define (simp-terms p) (simplify p combine-terms vars= cadr))
(define (simplify p combiner eq-test? selector)
  (define (simplify-helper p result) (if (null? p) result
        (let ((simplified (combiner (collect-like (car p) p eq-test? selector))))
          (if (null? simplified) result
              (simplify-helper (remove-like simplified (cdr p) eq-test? selector) (cons simplified result))))))
  (simplify-helper p '()))
(define (combine-terms like-terms) (let ((combined-car (foldr + 0 (map car like-terms))))
    (if (zero? combined-car) '() (mk-term combined-car (cadr (car like-terms))))))
(define (collect-like x p eq-test? selector) (filter (lambda (a) (eq-test? (selector a) (selector x))) p))
(define (remove-like x p eq-test? selector) (collect-like x p (lambda (a b) (not (eq-test? a b))) selector))
(define (simp-vars p)
  (define (simp-vars-helper p result)
    (cond ((null? p) result) ((constant? (car p)) (cons (car p) (simp-vars (cdr p))))
          (else (simp-vars-helper (cdr p)
				  (cons (mk-term (car (car p)) (simplify (cadr (car p)) combine-vars equal? car))
					result)))))
  (simp-vars-helper p '()))
(define (combine-vars like-vars) (let ((combined-pow (foldr + 0 (map cadr like-vars))))
    (if (zero? combined-pow) '() (mk-var (car (car like-vars)) combined-pow))))
(define (term* t1 t2) (mk-term (* (car t1) (car t2)) 
			       (cond ((and (constant? t1) (constant? t2)) '(())) 
				     ((constant? t1) (cadr t2))
                 	       ((constant? t2) (cadr t1))
			       (else (append (cadr t1) (cadr t2))))))
(define (vars= vs1 vs2) (cond ((and (null? vs1) (null? vs2)) #t)
			      ((and (equal? '(()) vs1) (equal? '(()) vs2)) #t)
			      ((or (equal? '(()) vs1) (equal? '(()) vs2)) #f)
			      (else (and (= (length vs1) (length vs2))
                                    (all-true? (map any-true? (cartesian-map v= vs1 vs2)))))))
(define (v= v1 v2) (and (equal? (car v1) (car v2)) (= (cadr v1) (cadr v2))))
(define (negate-poly p) (map (lambda (x) (mk-term (* -1 (car x)) (cadr x))) p))
(define (mk-term carf variabs) (cons carf (cons variabs '()))) (define (mk-var ltr pow) (mk-term ltr pow))
(define (constant? term) (if (null? term) #f (and (integer? (car term)) (equal? '(()) (cadr term)))))
(define (all-true? l) (foldr (lambda (x xs) (and (not (equal? #f x)) xs)) #t l))
(define (any-true? l) (foldr (lambda (x xs) (or (not (equal? #f x)) xs)) #f l))
(define (cartesian-map f l1 l2) (map (lambda (x) (map (lambda (y) (f x y)) l2)) l1))
(load "tests.ss")
