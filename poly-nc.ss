(define (p+ p1 p2) (clean (append p1 p2)))
(define (p- p1 p2) (p+ p1 (negate p2)))
(define (p* p1 p2) (clean (fold-right append '() (cartesian-map term* p1 p2))))
(define (p= p1 p2) (null? (p- p1 p2)))
(define (clean p) (simp-terms (simp-cadr p)))
(define (simp-terms p) (simplify p combine-terms vars= (lambda (term) (cadr term))))
(define (simplify p combiner eq-test? selector)
  (define (simplify-helper p result)
	  (if (null? p) result
	    (let ((simplified (combiner (collect-like (car p) p eq-test? selector))))
	      (if (null? simplified) result
		(simplify-helper (remove-like simplified (cdr p) eq-test? selector)
				 (cons simplified result))))))
  (simplify-helper p '()))
(define (combine-terms like-terms)
  (let ((combined-car (fold-right + 0 (map car like-terms))))
    (if (zero? combined-car) '()
      (mk-term combined-car (cadr (car like-terms))))))
(define (collect-like x p eq-test? selector) (filter (lambda (a) (eq-test? (selector a) (selector x))) p))
(define (remove-like x p eq-test? selector) (filter (lambda (a) (not (eq-test? (selector a) (selector x)))) p ))
(define (simp-cadr p)
  (define (simp-cadr-helper p result)
    (cond ((null? p) result)
	  ((constant? (car p)) (cons (car p) (simp-cadr (cdr p))))
	  (else (simp-cadr-helper
		  (cdr p)
		  (cons (mk-term (car (car p))
				 (simplify (cadr (car p))
					   combine-cadr
					   equal?
					   (lambda (v) (car v))))
			result)))))
  (simp-cadr-helper p '()))
(define (combine-cadr like-vars)
  (let ((combined-pow (fold-right + 0 (map cadr like-vars))))
    (if (zero? combined-pow) '()
      (mk-var (car (car like-vars)) combined-pow))))
(define (negate p) (map (lambda (x) (mk-term (* -1 (car x)) (cadr x))) p))
(define (term* t1 t2)
 (mk-term (* (car t1) (car t2))
	  (cond ((and (constant? t1) (constant? t2)) '(())) 
	        ((constant? t1) (cadr t2))
		((constant? t2) (cadr t1))
		(else (append (cadr t1) (cadr t2))))))
(define (vars= vs1 vs2)
  (cond ((and (null? vs1) (null? vs2)) #t)
      	((and (equal? '(()) vs1) (equal? '(()) vs2)) #t)
      	((or (equal? '(()) vs1) (equal? '(()) vs2)) #f)
      	(else (and (= (length vs1) (length vs2))
		   (all-true? (map any-true? (cartesian-map v= vs1 vs2)))))))
(define (v= v1 v2) (and (equal? (car v1) (car v2)) (= (cadr v1) (cadr v2))))
(define (mk-term coef variabs) (cons coef (cons variabs '())))
(define (mk-var ltr pow) (mk-term ltr pow))
(define (constant? term)
  (cond ((null? term) #f)
	((null? (car term)) #f)
	(else (and (integer? (car term)) 
		(equal? '(()) (cadr term))))))
(define (all-true? l) (if (null? l) #t (and (not (equal? #f (car l))) (all-true? (cdr l)))))
(define (any-true? l) (if (null? l) #f (or (not (equal? #f (car l))) (any-true? (cdr l)))))
(define (filter pred? l) (fold-right (lambda (x acc) (if (pred? x) (cons x acc) acc)) '() l))
(define (fold-right f end l) (if (null? l) end  (f (car l) (fold-right f end (cdr l)))))
(define (cartesian-map f l1 l2) (map (lambda (x) (map (lambda (y) (f x y)) l2)) l1))
(load "tests.ss")
(exit)
