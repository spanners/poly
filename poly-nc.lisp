(setq poly "/path/to/this/file/polynomial.lisp")
(setq tests "/path/to/tests/file/tests.lisp")
(defun rl () (load poly))
(defun tst () (load tests))
(defun p+ (p1 p2) (clean (clean (append p1 p2))))
(defun p- (p1 p2) (p+ p1 (negate p2)))
(defun p* (p1 p2) (clean (pmult (clean p1) (clean p2))))
(defun p= (p1 p2) (pequal (clean p1) (clean p2)))
(defun clean (p) (simp-terms (simp-vars (rem-zero p)))) 
(defun simp-terms (p)
  (simplifier p combine-terms vars= (lambda (x) (vars x))))
(defun simplifier (L combiner test selector)
  (cond ((null L) '())
	(t (let ((simplified 
		   (combiner (collectlike (car L) L test selector))))
		(cons simplified 
		      (simplifier
			(removelike simplified 
				(cdr L) test selector)
				  combiner test selector))))))
(defun combine-terms (lterms)
  (mk-term (accumulate + 0 (map coef lterms)) (vars (pcar lterms))))
(defun collectlike (x L test selector)
  (cond ((null L) '())
	((test (selector x) (selector (car L)))
	 (cons (car L) (collectlike x (cdr L) test selector)))
	(t (collectlike x (cdr L) test selector))))
(defun simp-vars (p)
  (cond ((null p) '())
	((constantp (pcar p)) (cons (pcar p) (simp-vars (pcdr p)))) 
	(t (cons (mk-term (coef (pcar p))
			  (removelike 0 
				  (simplifier (vars (pcar p)) 
					      combine-vars 
					      equal 
					      (lambda (v) (vcar v)))
				  equal 
				  (lambda (v) 
				    (cond ((not (listp v)) v) 
						    (t (power v))))))
		 (simp-vars (pcdr p))))))
(defun combine-vars (lvars)
  (mk-var (letter (vcar lvars)) (accumulate + 0 (map power lvars))))
(defun rem-zero (p)
  (removelike 0 p = (lambda (x) (cond ((not (listp x)) x) (t (coef x))))))
(defun removelike (x L test selector)
  (cond ((null L) '())
	((test (selector x) (selector (car L))) (removelike x (cdr L) test selector))
	(t (cons (car L) (removelike x (cdr L) test selector)))))
(defun negate (p) (map (lambda (x) (mk-term (* -1 (coef x)) (vars x))) p))
(defun pmult (p1 p2) (accumulate append '() (mmap t* p1 p2)))
(defun t* (t1 t2)
 (mk-term (* (coef t1) (coef t2))
	  (cond ((and (constantp t1) (constantp t2)) no-vars) 
	        ((constantp t1) (vars t2))
		((constantp t2) (vars t1))
		(t (append (vars t1) (vars t2))))))
(defun pequal (p1 p2) (and (= (length p1) (length p2)) 
			   (all (map any (mmap t= p1 p2)))))
(defun t= (t1 t2)
  (cond ((and (constantp t1) (constantp t2)) (= (coef t1) (coef t2)))
	(t (and (= (coef t1) (coef t2))
		(vars= (vars t1) (vars t2))))))
(defun vars= (vs1 vs2) (cond ((and (null vs1) (null vs2)) t)
			     ((and (equal no-vars vs1) (equal no-vars vs2)) t)
			     ((or (equal no-vars vs1) (equal no-vars vs2)) nil)
			     (t (and (= (length vs1) (length vs2))
				     (all (map any (mmap v= vs1 vs2)))))))
(defun v= (v1 v2) (and (equal (letter v1) (letter v2))
		       (= (power v1) (power v2))))
(defun mk-term (coeff variabs) (cons coeff (cons variabs '())))
(defun mk-var (ltr pow) (mk-term ltr pow))
(defun constantp (term)
  (cond ((null term) nil)
	((null (coef term)) nil)
	(t (and (integerp (coef term)) 
		(equal (vars term) no-vars)))))
(defun all (L)
  (cond ((null L) t)
	(else (and (not (equal nil (car L))) (all (cdr L))))))
(defun any (L)
  (cond ((null L) nil)
	(else (or (not (equal nil (car L))) (any (cdr L))))))
(defun mmap (f l1 l2) (map (lambda (x) (map (lambda (y) (f x y)) l2)) l1))
(setq pcar car) (setq pcdr cdr) (setq coef car) (setq vars cadr) 
(setq vcar car) (setq vcdr cdr) (setq letter car) (setq power cadr) 
(setq empty '()) (setq no-vars '(())) 
