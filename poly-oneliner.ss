(require srfi/1)(define(p+ p1 p2)(simp-terms(simp-vars(append p1 p2))))(define(p- p1 p2)(p+ p1(negate-poly p2)))(define(p* p1 p2)(simp-terms(simp-vars(apply append(cartesian-map term* p1 p2)))))(define(p= p1 p2)(null?(p- p1 p2)))(define(simp-terms p)(simplify p combine-terms vars= cadr))(define(simp-vars p)(define(simp-vars-helper p result)(cond((null? p)result)((constant?(car p))(cons(car p)(simp-vars(cdr p))))(else(simp-vars-helper(cdr p)(cons(mk-term(caar p)(simplify(cadar p) combine-vars equal? car))result)))))(simp-vars-helper p '()))(define(simplify p combiner eq-test? selector)(define(simplify-helper p result)(if(null? p) result(let((simplified(combiner(collect-like(car p) p eq-test? selector))))(if(null? simplified) result(simplify-helper(remove-like simplified(cdr p) eq-test? selector)(cons simplified result))))))(simplify-helper p '()))(define(combine-terms like-terms)(let((combined-car(foldr + 0(map car like-terms))))(if(zero? combined-car) '()(mk-term combined-car(cadar like-terms)))))(define(combine-vars like-vars)(let((combined-pow(foldr + 0(map cadr like-vars))))(if(zero? combined-pow) '()(mk-var(caar like-vars) combined-pow))))(define(collect-like x p eq-test? selector)(filter(lambda(a)(eq-test?(selector a)(selector x)))p))(define(remove-like x p eq-test? selector)(collect-like x p(lambda(a b)(not(eq-test? a b)))selector))(define(term* t1 t2)(mk-term(*(car t1)(car t2))(cond((and(constant? t1)(constant? t2)) '(()))((constant? t1)(cadr t2))((constant? t2)(cadr t1))(else(append(cadr t1)(cadr t2))))))(define(vars= vs1 vs2)(cond((and(null? vs1)(null? vs2)) #t)((and(equal? '(())vs1)(equal? '(())vs2)) #t)((or(equal? '(())vs1)(equal? '(())vs2)) #f)(else(and(=(length vs1)(length vs2))(every identity(map(lambda(l)(any identity l))(cartesian-map v= vs1 vs2)))))))(define(v= v1 v2)(and(equal?(car v1)(car v2))(=(cadr v1)(cadr v2))))(define(negate-poly p)(map(lambda(x)(mk-term(* -1(car x))(cadr x)))p))(define(mk-term coef variabs)(cons coef(cons variabs '())))(define(mk-var ltr pow)(mk-term ltr pow))(define(constant? term)(if(null? term) #f(and(integer?(car term))(equal? '(())(cadr term)))))(define(cartesian-map f l1 l2)(map(lambda(x)(map(lambda(y)(f x y))l2))l1))(load "tests.ss")
